"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleBandit = void 0;
const Sampling_1 = require("./Sampling");
const SimpleOracle_1 = require("./SimpleOracle");
const SimpleMutex_1 = require("./SimpleMutex");
class SimpleBandit {
    constructor({ oracle: oracle, actions, temperature = 0.5, slateSize = 1, slateNegativeSampleWeight = 1, }) {
        this.mutex = new SimpleMutex_1.SimpleMutex();
        this.oracle = Array.isArray(oracle)
            ? oracle
            : oracle
                ? [oracle]
                : [new SimpleOracle_1.SimpleOracle()];
        this.targetLabels = [
            ...new Set(this.oracle.map((oracle) => oracle.targetLabel)),
        ];
        this.actionsMap = this._processActions(actions);
        this.temperature = temperature;
        this.slateSize = slateSize;
        this.slateNegativeSampleWeight = slateNegativeSampleWeight;
    }
    _processActions(input) {
        const actionsMap = {};
        if (Array.isArray(input)) {
            input.forEach((item) => {
                if (typeof item === "string") {
                    actionsMap[item] = { actionId: item, features: {} };
                }
                else {
                    actionsMap[item.actionId] = item;
                }
            });
        }
        else {
            Object.keys(input).forEach((key) => {
                const value = input[key];
                if (Array.isArray(value)) {
                    actionsMap[key] = {
                        actionId: key,
                        features: value.reduce((acc, curr) => {
                            acc[curr] = 1;
                            return acc;
                        }, {}),
                    };
                }
                else {
                    actionsMap[key] = { actionId: key, features: value };
                }
            });
        }
        return actionsMap;
    }
    toState() {
        return {
            oracleStates: this.oracle.map((oracle) => oracle.getOracleState()),
            temperature: this.temperature,
            slateSize: this.slateSize,
        };
    }
    static fromState(state, actions) {
        const oracles = state.oracleStates.map((oracleState) => SimpleOracle_1.SimpleOracle.fromOracleState(oracleState));
        return new SimpleBandit({
            oracle: oracles,
            actions: actions,
            temperature: state.temperature,
            slateSize: state.slateSize,
        });
    }
    toJSON() {
        return JSON.stringify(this.toState());
    }
    static fromJSON(json, actions) {
        const state = JSON.parse(json);
        return SimpleBandit.fromState(state, actions);
    }
    _getActionScore(actionId, context, features) {
        return this.oracle.reduce((score, oracle) => score +
            oracle.oracleWeight * oracle.predict(actionId, context, features), 0);
    }
    getScoredActions(context = {}, options = {}) {
        let scoredActions = [];
        let actionIds = Object.keys(this.actionsMap);
        if (options === null || options === void 0 ? void 0 : options.include)
            actionIds = actionIds.filter((action) => { var _a; return (_a = options === null || options === void 0 ? void 0 : options.include) === null || _a === void 0 ? void 0 : _a.includes(action); });
        if (options === null || options === void 0 ? void 0 : options.exclude)
            actionIds = actionIds.filter((action) => { var _a; return !((_a = options === null || options === void 0 ? void 0 : options.exclude) === null || _a === void 0 ? void 0 : _a.includes(action)); });
        for (let i = 0; i < actionIds.length; i++) {
            const actionId = actionIds[i];
            const action = this.actionsMap[actionId];
            const actionScore = this._getActionScore(action.actionId, context, action.features);
            const softmaxNumerator = Math.exp(actionScore / this.temperature);
            scoredActions.push({
                actionId: actionId,
                score: actionScore,
                probability: softmaxNumerator,
            });
        }
        if (this.temperature > 0) {
            const SoftmaxDenominator = scoredActions.reduce((a, b) => a + b.probability, 0);
            scoredActions = scoredActions.map((ex) => ({
                actionId: ex.actionId,
                score: ex.score,
                probability: ex.probability / SoftmaxDenominator,
            }));
        }
        else {
            const maxScore = Math.max(...scoredActions.map((action) => action.score));
            scoredActions = scoredActions.map((ex) => ({
                actionId: ex.actionId,
                score: ex.score,
                probability: ex.score === maxScore ? 1 : 0,
            }));
        }
        return scoredActions;
    }
    getScoredActionsPerOracle(context = {}, options = {}) {
        const scoredActions = this.getScoredActions(context, options);
        const scoredActionsPerOracle = [];
        for (let scoredAction of scoredActions) {
            const scoredActionPerOracle = {
                actionId: scoredAction.actionId,
                weightedScore: scoredAction.score,
                probability: scoredAction.probability,
            };
            for (let oracle of this.oracle) {
                const oracleScore = oracle.predict(scoredAction.actionId, context, this.actionsMap[scoredAction.actionId].features);
                scoredActionPerOracle[oracle.name] = oracleScore;
            }
            scoredActionsPerOracle.push(scoredActionPerOracle);
        }
        return scoredActionsPerOracle;
    }
    _generateClickOracleTrainingData(recommendation, selectedActionId = undefined) {
        if ("actionId" in recommendation) {
            // IRecommendation
            const trainingData = [
                {
                    recommendationId: recommendation.recommendationId,
                    actionId: recommendation.actionId,
                    features: this.actionsMap[recommendation.actionId].features,
                    context: recommendation.context,
                    click: recommendation.actionId === selectedActionId ? 1 : 0,
                    probability: recommendation.probability,
                },
            ];
            return trainingData;
        }
        else {
            // ISlate
            const trainingData = [];
            for (let index = 0; index < recommendation.slateItems.length; index++) {
                const actionId = recommendation.slateItems[index].actionId;
                const recommendedAction = this.actionsMap[actionId];
                if (!recommendedAction) {
                    throw new Error(`Failed to generate training data for recommended exercise at index ${index}.`);
                }
                const context = recommendation.context;
                const features = recommendedAction.features;
                const click = recommendedAction.actionId === selectedActionId ? 1 : 0;
                const sampleWeight = click === 0 ? this.slateNegativeSampleWeight : 1.0;
                const probability = recommendation.slateItems[index].probability;
                trainingData.push({
                    recommendationId: recommendation.recommendationId,
                    actionId: actionId,
                    features: features,
                    context: context,
                    click: click,
                    probability: probability,
                    sampleWeight: sampleWeight,
                });
            }
            return trainingData;
        }
    }
    _generateRecommendationId() {
        // without uuid dependency
        return ("id-" +
            Math.random().toString(36).substr(2, 16) +
            "-" +
            Date.now().toString(36));
    }
    recommend(context = {}, options = {}) {
        let scoredActions = this.getScoredActions(context, options);
        let sampleIndex;
        if (this.temperature === 0) {
            sampleIndex = scoredActions.findIndex((action) => action.score ===
                Math.max(...scoredActions.map((action) => action.score)));
        }
        else {
            const probabilities = scoredActions.map((action) => action.probability);
            sampleIndex = (0, Sampling_1.SampleFromProbabilityDistribution)(probabilities);
        }
        const recommendedAction = scoredActions[sampleIndex];
        const recommendation = {
            recommendationId: this._generateRecommendationId(),
            context: context,
            actionId: recommendedAction.actionId,
            score: recommendedAction.score,
            probability: recommendedAction.probability,
        };
        return recommendation;
    }
    slate(context = {}, options = {}) {
        var _a;
        let scoredActions = this.getScoredActions(context, options);
        const slateItems = [];
        const slateSize = Math.min((_a = options.slateSize) !== null && _a !== void 0 ? _a : this.slateSize, Object.keys(this.actionsMap).length);
        let sampleIndex;
        for (let index = 0; index < slateSize; index++) {
            if (this.temperature === 0) {
                sampleIndex = scoredActions.findIndex((action) => action.score ===
                    Math.max(...scoredActions.map((action) => action.score)));
            }
            else {
                const probabilities = scoredActions.map((action) => action.probability);
                sampleIndex = (0, Sampling_1.SampleFromProbabilityDistribution)(probabilities);
            }
            slateItems[index] = scoredActions[sampleIndex];
            scoredActions.splice(sampleIndex, 1);
        }
        const slate = {
            recommendationId: this._generateRecommendationId(),
            context: context,
            slateItems: slateItems,
        };
        return slate;
    }
    accept(recommendation) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.targetLabels.includes("click")) {
                    throw new Error("no oracle with `click` as targetLabel, so cannot use accept()");
                }
                const trainingData = this._generateClickOracleTrainingData(recommendation, recommendation.actionId);
                yield this.train(trainingData);
                resolve(trainingData);
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    choose(slate, actionId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.targetLabels.includes("click")) {
                    throw new Error("no oracle with `click` as targetLabel, so cannot use accept()");
                }
                if (actionId == undefined) {
                    throw new Error(`need to provide actionId`);
                }
                const actionIds = slate.slateItems.map((action) => action.actionId);
                if (!actionIds.includes(actionId)) {
                    throw new Error(`ActionId ${actionId} is not in slateItems`);
                }
                const trainingData = this._generateClickOracleTrainingData(slate, actionId);
                yield this.train(trainingData);
                resolve(trainingData);
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    reject(recommendation) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.targetLabels.includes("click")) {
                    throw new Error("no oracle with `click` as targetLabel, so cannot use accept()");
                }
                const trainingData = this._generateClickOracleTrainingData(recommendation, undefined);
                yield this.train(trainingData);
                resolve(trainingData);
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    feedback(recommendation_or_slate, label, value, actionId = undefined) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.targetLabels.includes(label)) {
                    throw new Error(`label ${label} not in any of weightedOracles`);
                }
                let recommendedAction;
                let probability;
                if ("actionId" in recommendation_or_slate) {
                    // IRecommendation
                    if (actionId && actionId !== recommendation_or_slate.actionId) {
                        throw new Error(`actionId ${actionId} does not match recommendation.actionId ${recommendation_or_slate.actionId}`);
                    }
                    recommendedAction = this.actionsMap[recommendation_or_slate.actionId];
                    probability = recommendation_or_slate.probability;
                }
                else {
                    // ISlate
                    if (actionId === undefined) {
                        throw new Error(`actionId must be provided for slate`);
                    }
                    const foundAction = recommendation_or_slate.slateItems.find((action) => action.actionId === actionId);
                    if (!foundAction) {
                        throw new Error(`No action found in slate with actionId ${actionId}`);
                    }
                    if (!this.actionsMap.hasOwnProperty(actionId)) {
                        throw new Error(`No action found for this bandit with actionId ${actionId}`);
                    }
                    recommendedAction = this.actionsMap[actionId];
                    probability = foundAction.probability;
                }
                const trainingData = [
                    {
                        recommendationId: recommendation_or_slate.recommendationId,
                        actionId: recommendedAction.actionId,
                        features: recommendedAction.features,
                        context: recommendation_or_slate.context,
                        [label]: value,
                        probability: probability,
                    },
                ];
                yield this.train(trainingData);
                resolve(trainingData);
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    train(trainingData) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.mutex.run(() => {
                for (const oracle of this.oracle) {
                    oracle.fit(trainingData);
                }
            });
        });
    }
}
exports.SimpleBandit = SimpleBandit;
