import { IAction, IScoredAction, IActionsInput } from "./interfaces/IAction";
import { IRecommendation, ISlate } from "./interfaces/IRecommendation";
import { ITrainingData } from "./interfaces/ITrainingData";
import { ISimpleBandit } from "./interfaces/ISimpleBandit";
import { ISimpleBanditState } from "./interfaces/IState";
import { SimpleOracle } from "./SimpleOracle";
export declare class SimpleBandit implements ISimpleBandit {
    private mutex;
    oracle: SimpleOracle[];
    targetLabels: string[];
    temperature: number;
    actionsMap: Record<string, IAction>;
    slateSize: number;
    slateNegativeSampleWeight: number;
    constructor({ oracle: oracle, actions, temperature, slateSize, slateNegativeSampleWeight, }: {
        oracle?: SimpleOracle | SimpleOracle[];
        actions: IActionsInput;
        temperature?: number;
        slateSize?: number;
        slateNegativeSampleWeight?: number;
    });
    _processActions(input: IActionsInput): Record<string, IAction>;
    toState(): ISimpleBanditState;
    static fromState(state: ISimpleBanditState, actions: IAction[]): SimpleBandit;
    toJSON(): string;
    static fromJSON(json: string, actions: IAction[]): SimpleBandit;
    _getActionScore(actionId: string, context: {
        [feature: string]: number;
    }, features: {
        [feature: string]: number;
    }): number;
    getScoredActions(context?: {
        [feature: string]: number;
    }, options?: {
        include?: string[];
        exclude?: string[];
    }): IScoredAction[];
    getScoredActionsPerOracle(context?: {
        [feature: string]: number;
    }, options?: {
        include?: string[];
        exclude?: string[];
    }): Array<{
        [key: string]: number | string;
    }>;
    _generateClickOracleTrainingData(recommendation: IRecommendation | ISlate, selectedActionId?: string | undefined): ITrainingData[];
    _generateRecommendationId(): string;
    recommend(context?: {
        [feature: string]: number;
    }, options?: {
        include?: string[];
        exclude?: string[];
    }): IRecommendation;
    slate(context?: {
        [feature: string]: number;
    }, options?: {
        include?: string[];
        exclude?: string[];
        slateSize?: number;
    }): ISlate;
    accept(recommendation: IRecommendation): Promise<ITrainingData[]>;
    choose(slate: ISlate, actionId: string): Promise<ITrainingData[]>;
    reject(recommendation: IRecommendation | ISlate): Promise<ITrainingData[]>;
    feedback(recommendation_or_slate: IRecommendation | ISlate, label: string, value: number, actionId?: string | undefined): Promise<ITrainingData[]>;
    train(trainingData: ITrainingData[]): Promise<void>;
}
